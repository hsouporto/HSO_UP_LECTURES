# Solutions Ficha 01 (HSO)

1. Consider the program hello.c:

```
#include <stdio.h>
int main() {
    printf("Hello World!\n");
    return 0;
}
```


Check what happens when only the preprocessor part of the C compiler is executed:
$ gcc -E hello.c

**Response:** 

It tells GCC to stop after the preprocessing stage. Details in the link.
https://gcc.gnu.org/onlinedocs/gcc/Overall-Options.html#Overall-Options
It will show the output the compiler produces after expanding all macros.

**Some more details:**

You are instructing the GCC (GNU Compiler Collection) to run only the preprocessor on the "hello.c" source file. The preprocessor is responsible for handling preprocessor directives, macro expansion, and file inclusion.

Here's what happens when you run the preprocessor:

The #include <stdio.h> directive is processed, and the contents of the "stdio.h" header file are inserted into the code at that point.

The int main() { and return 0;} lines are left unchanged because they are not preprocessor directives.

The printf("Hello World!\n"); line is also left unchanged because it is a regular code statement, not a preprocessor directive.

Comments (lines starting with //) are left unchanged because they are also not preprocessor directives.

The preprocessor removes whitespace and newline characters as needed for code readability.

The result of running only the preprocessor on the "hello.c" source file is that it processes the #include directive by including the contents of the "stdio.h" header file and performs minimal text transformations. The output typically contains the processed code, including the code from the included header file.

The output may be quite large and includes not only your code but also the code from any included header files that are indirectly or directly referenced. If you want to see the output, you can redirect it to a file or view it in your terminal.

====================================================


To inspect the Intel x86 assembly code produced by the C compiler for the program you
can execute:
```
$ gcc -S hello.c
```

Check the result in the file hello.s.

**Response:**

Generated the assembly (stops at assembly stage) allows view the assembly file

Execute the following commands and observe the results:
```
$ gcc hello.c (generates a.out by default)
$ gcc -o hello hello.c (generates output as hello)
$ gcc -Wall -o hello hello.c (Activate All warnings and set out to be hello)
```

You should always compile a C program with the -Wall option so that the compiler always
presents warnings. These are problems detected by the compiler that, despite not blocking
the compiler from generating an executable file, may give rise to runtime errors. You
should correct these as if they are full fledged compilation errors.

To use the C debugger, an auxiliar program that allows you to run the executable file
generated by the compiler one step at a time and to inspect the state of the program
variables. To include debugging support you must use the -g option.
```
$ gcc -g -o hello hello.c ( -g generate debug information)
$ gdb hello
gdb> break main (set breakpoint at main)
gdb> run (run until breakpoint)
gdb> next (continue next)
gdb> ... q (quit)
```
====================================================


2. Consider the program trig.c that calculates tables of values for the trigonometric
functions sin x and cos x for integer angles given in degrees (from 0 to 360).

```
#include <stdio.h>
#define START
 0
#define ONE_TURN
 360
double cos_table[ONE_TURN];
double sin_table[ONE_TURN];

void build_tables() {
    int i;
    for (i = START; i < ONE_TURN; i++) {
        sin_table[i] = sin(M_PI * i / 180.0);
        cos_table[i] = cos(M_PI * i / 180.0);
    }
}

double sin_degrees(int angle) {
    return sin_table[angle % ONE_TURN];
}

double cos_degrees(int angle) {
    return cos_table[angle % ONE_TURN];
}

int main() {
    build_tables();
    printf("sin(20) = %f\n", sin_degrees(20));
    printf("cos(80) = %f\n", cos_degrees(425));
    printf("tan(60) = %f\n", sin_degrees(60) / cos_degrees(60));
    return 0;
}
````

Compile the program with the command: gcc -Wall -o trig trig.c. The compiler complains about some problem and does not generate an executable. Can you understand
why? (hint: pay close attention to the error messages).

Correct the error and compile the program again with the same comand. The compiler
complains again? What is the problem this time? How can you solve it? (hint: run the
commands man sin or man cos).

**Response:** 
Math library neeed to be linked in compilation so -lm flag is needed

```
gcc -Wall -lm  -o  trig trig.c (-lm link math)
````

This is due to historical reason 
Quote "To give an example, when I still worked in embedded computing, we used standard compilers (Microsoft and Borland) to generate code for our processors (Z80, 80186 and 68030). If the compilers had by default linked to the math library we would have been in trouble as none of our systems had floating point capabilities or even needed them.

It's true that 30 years afterwards it seems silly but the reason was sound at that time.
End"

**More details:**

The compilation error you're encountering is likely due to the fact that the code uses trigonometric functions like sin() and cos() from the math library (<math.h>) without including the necessary header and without linking the math library during compilation. This omission leads to unresolved references to these functions during the compilation process.

To fix this issue, you should do the following:

Include the <math.h> header at the beginning of your code to declare the trigonometric functions.

Link the math library (-lm) during compilation to resolve the references to the trigonometric functions.

Here's the corrected version of your code:

```
#include <stdio.h>
#include <math.h> // Include the math.h header for trigonometric functions

#define START 0
#define ONE_TURN 360

double cos_table[ONE_TURN];
double sin_table[ONE_TURN];

void build_tables() {
    int i;
    for (i = START; i < ONE_TURN; i++) {
        sin_table[i] = sin(M_PI * i / 180.0);
        cos_table[i] = cos(M_PI * i / 180.0);
    }
}

double sin_degrees(int angle) {
    return sin_table[angle % ONE_TURN];
}

double cos_degrees(int angle) {
    return cos_table[angle % ONE_TURN];
}

int main() {
    build_tables();
    printf("sin(20) = %f\n", sin_degrees(20));
    printf("cos(80) = %f\n", cos_degrees(425));
    printf("tan(60) = %f\n", sin_degrees(60) / cos_degrees(60));
    return 0;
}
````

Now, when you compile the code using the command gcc -Wall -o trig trig.c -lm, it should compile successfully without any complaints about unresolved references to sin() and cos(), and it will generate the executable "trig" as expected. The -lm flag is used to link the math library during compilation.

====================================================


3. Consider the following program, pointers1.c, that aims to exemplify some aspects
of the use of pointers in C, specifically, the operators & (“address of”) and * (“contentaddress”).

```
int main() {
    int i, j, *p, *q;
    i = 5;
    p = &i;
    *p = 7; //i = 7
    j = 3;
    p = &j; // copy pojnter to p pinter
    q = p;  // address pointer
    p = &i; // p gest the address of i
    *q = 2; // J will be set to 2 (it has the pointer of j)
    return 0;
}
```

Compile the program with the command: gcc -Wall -o pointers1 pointers1.c and
watch what happens to the variables by adding the following line at different points in the program:

```
printf("i=%d, j=%d, p=%p, q=%p\n", i, j, p, q);
```

Make a drawing that represents the system memory that shows the creation of the variables
i, j, p and q and follow the execution of the program by changing their values in the
drawing.

**Response:**

i=7, j=4198464, p=0x7ffd7229992c, q=0x7ffd72299a30
i=7, j=2, p=0x7ffd7229992c, q=0x7ffd72299928

====================================================


4. Consider the program char_array.c that moves through an array of characters:

```
#include <stdio.h>
int main() {
    int i;
    char msg[] = "Hello World";
    for (i = 0; i < sizeof(msg); i++) {
        printf("%c <--> %c\n", msg[i], *(msg + i));
    }
    return 0;
}
```

Compile it and execute it. How do you explain the result? Variable msg behaves as if it is
of what type? Each increment of i corresponds to how many bytes?

**Response:** 
Each increment of i correspond to 1 Byte

````
#include <stdio.h>
int main() {
    int i;
    int primes[] = {2, 3, 5, 7, 11};
    for (i = 0; i < sizeof(primes)/sizeof(int); i++) {
        printf("%d <--> %d\n", primes[i], *(primes + i));
    }
    return 0;
}
````

Compile it and execute it. How do you explain the result? Variable primes behaves asit is of what type? Each increment of i corresponds to how many bytes?

**Response:** 

Each increment corresponds to 4 bytes (len elements 5*4 /4 )

=================================================


5. Consider the programs, call_by_value.c:

```
void swap(int n1, int n2) {
    int temp = n1;
    n1 = n2;
    n2 = temp;
}

int main() {
    int n1 = 1;
    int n2 = 2;
    swap(n1, n2);
    printf("n1: %d n2: %d\n", n1, n2);
    return 0;
}
```

and call_by_reference.c:

```
void swap(int *p1, int *p2) {
    int temp = *p1;
    *p1 = *p2;
    *p2 = temp;
}

int main() {
    int n1 = 1;
    int n2 = 2;
    swap(&n1, &n2);
    printf("n1: %d n2: %d\n", n1, n2);
    return 0;
}
```

Make a drawing that represents the system memory that shows the creation of the variablesn1, n2, p1 and p2 and follow the execution of the program by changing their values indrawing.

Can you understand the difference between the two programs? Why is it that in the second program the values of n1 and n2 are swapped, unlike what happens in the first program?

**Response:** 
The first program we pass the value, but the originals stay the same, nothing happens 
to the originals n1 and n2. In pointer version we pass the references, so we changed the original values (same address)

================================================


6. Consider the programs bad_pointer.c:

```
#include <stdio.h>
int* get_int() {
    int i = 2;
    return &i; (problem  return address of variable of function that will be destroyed after return)
}

int main() {
    int* p = get_int();
    printf("integer = %d\n", *p);
    return 0;
}
```

and good_pointer.c:
```
#include <stdio.h>
#include <stdlib.h>
int* get_int() {
    int* p = (int*)malloc(sizeof(int));
    *p =2;
    return p;
}

int main() {
    int* p = get_int();
    printf("integer = %d\n", *p);
    return 0;
}
```

Compile and execute them. Note that, in the case of bad_pointer.c you have to compile with option -w to disconnect all warnings from the C compiler. Why? Can you understand what is happening?

**Response:** 

With bad pointer we are returning the addres from the internal variable of the function that no longuer exist after returned. The value must be  saved in the heap


Recompile the program gcc -g -w -o bad_pointer bad_pointer bad_pointer.c and run it with gdb

```
$ gdb bad_pointer
gdb> break main
gdb> run
gdb> step
gdb> ENTER
gdb> ...
```

Where is the error? Why?
Note. Several scenarios can give rise to errors in the access to memory during the execution of a program. Such errors are usually reported by the operating system as segmentation fault or bus error and result invariably in the abrupt interruption of the program. 

Most commonly, these scenarios result from an improper use of pointers, namely from trying to apply the * operator to an invalid pointer. The following C snippets show three typical errors:
```
/*
* Null Pointer: o endereço NULL n~
 ao é válido
*/
char *p1 = NULL;
...
char c1 = *p1; /* erro em runtime */
/*
* Wild Pointer: p2 n~
 ao foi inicializado e tem um endereço inválido
*/
char *p2;
...
char c2 = *p2; /* erro em runtime */
/*
* Dangling Pointer: um apontador que deixou de ser válido
*/
char *p3 = (char*)malloc(sizeof(char));
...
free(p3);
...
char c3 = *p3; /* erro em runtime */
```
================================================


7. Copy the following code to a file trace.c and compile it using gcc -rdynamic -Wall trace.c -o trace. Observe the output and try to explain it based on the structure of the program. Then, add this function:

```
void f4(void) { print_trace("f4"); return; }
```

and replace function f3 by:

```
void f3(void) { f4(); print_trace("f3"); return; }
````

What happens then? Why?

**Response:**

Original:
```
[hso@new-host ficha_01]$ gcc -rdynamic -Wall trace.c -o trace
[hso@new-host ficha_01]$ ./trace 
------------ BEGIN (f4) ---------------------
Obtained 8 stack frames.
./trace(print_trace+0x3f) [0x4011a5]
./trace(f4+0xe) [0x401245]
./trace(f3+0x9) [0x401251]
./trace(f2+0x9) [0x401267]
./trace(f1+0x9) [0x40127d]
./trace(main+0x9) [0x401293]
/lib64/libc.so.6(__libc_start_main+0xf2) [0x7fa8072bb042]
./trace(_start+0x2e) [0x4010ae]
------------ END (f4) ---------------------
------------ BEGIN (f3) ---------------------
Obtained 7 stack frames.
./trace(print_trace+0x3f) [0x4011a5]
./trace(f3+0x13) [0x40125b]
./trace(f2+0x9) [0x401267]
./trace(f1+0x9) [0x40127d]
./trace(main+0x9) [0x401293]
/lib64/libc.so.6(__libc_start_main+0xf2) [0x7fa8072bb042]
./trace(_start+0x2e) [0x4010ae]
------------ END (f3) ---------------------
------------ BEGIN (f2) ---------------------
Obtained 6 stack frames.
./trace(print_trace+0x3f) [0x4011a5]
./trace(f2+0x13) [0x401271]
./trace(f1+0x9) [0x40127d]
./trace(main+0x9) [0x401293]
/lib64/libc.so.6(__libc_start_main+0xf2) [0x7fa8072bb042]
./trace(_start+0x2e) [0x4010ae]
------------ END (f2) ---------------------
------------ BEGIN (f1) ---------------------
Obtained 5 stack frames.
./trace(print_trace+0x3f) [0x4011a5]
./trace(f1+0x13) [0x401287]
./trace(main+0x9) [0x401293]
/lib64/libc.so.6(__libc_start_main+0xf2) [0x7fa8072bb042]
./trace(_start+0x2e) [0x4010ae]
------------ END (f1) ---------------------
------------ BEGIN (main) ---------------------
Obtained 4 stack frames.
./trace(print_trace+0x3f) [0x4011a5]
./trace(main+0x13) [0x40129d]
/lib64/libc.so.6(__libc_start_main+0xf2) [0x7fa8072bb042]
./trace(_start+0x2e) [0x4010ae]
------------ END (main) ---------------------
``


add f4

```
[hso@new-host ficha_01]$ gcc -rdynamic -Wall trace.c -o trace
[hso@new-host ficha_01]$ ./trace 
------------ BEGIN (f4) ---------------------
Obtained 8 stack frames.
./trace(print_trace+0x3f) [0x4011a5]
./trace(f4+0xe) [0x401245]
./trace(f3+0x9) [0x401251]
./trace(f2+0x9) [0x401267]
./trace(f1+0x9) [0x40127d]
./trace(main+0x9) [0x401293]
/lib64/libc.so.6(__libc_start_main+0xf2) [0x7fa8072bb042]
./trace(_start+0x2e) [0x4010ae]
------------ END (f4) ---------------------
------------ BEGIN (f3) ---------------------
Obtained 7 stack frames.
./trace(print_trace+0x3f) [0x4011a5]
./trace(f3+0x13) [0x40125b]
./trace(f2+0x9) [0x401267]
./trace(f1+0x9) [0x40127d]
./trace(main+0x9) [0x401293]
/lib64/libc.so.6(__libc_start_main+0xf2) [0x7fa8072bb042]
./trace(_start+0x2e) [0x4010ae]
------------ END (f3) ---------------------
------------ BEGIN (f2) ---------------------
Obtained 6 stack frames.
./trace(print_trace+0x3f) [0x4011a5]
./trace(f2+0x13) [0x401271]
./trace(f1+0x9) [0x40127d]
./trace(main+0x9) [0x401293]
/lib64/libc.so.6(__libc_start_main+0xf2) [0x7fa8072bb042]
./trace(_start+0x2e) [0x4010ae]
------------ END (f2) ---------------------
------------ BEGIN (f1) ---------------------
Obtained 5 stack frames.
./trace(print_trace+0x3f) [0x4011a5]
./trace(f1+0x13) [0x401287]
./trace(main+0x9) [0x401293]
/lib64/libc.so.6(__libc_start_main+0xf2) [0x7fa8072bb042]
./trace(_start+0x2e) [0x4010ae]
------------ END (f1) ---------------------
------------ BEGIN (main) ---------------------
Obtained 4 stack frames.
./trace(print_trace+0x3f) [0x4011a5]
./trace(main+0x13) [0x40129d]
/lib64/libc.so.6(__libc_start_main+0xf2) [0x7fa8072bb042]
./trace(_start+0x2e) [0x4010ae]
------------ END (main) ---------------------
````

==============================================


8. Consider the following C code fragments that make use of pointers. Explain how the pointers are being used, what part of the p+rocess address space is being used, what of information is being pointed at and if the operations are safe (i.e., do not result insegmentation fault or a bus error).

```
(1)
...
void f() {
    int x;
    g(&x);
}
...
a
(2)
...
int* f() {
    int x;
    return &x;
} NOTE: Bad, return address of value that is detroyed after return
...
(3)
...
int* f() {
    int* x = (int*)malloc(sizeof(int));
    return x;
}
...
(4)
...
int g(int (*h)(int), int y) {
    return h(y + 2);
}
int f(int x) {
    return x*x;
}
int main() {
    printf("value: %d\n", g(f,2));
    return 0;
}
````

**Response:**

See the coomments made

================================================







